#include "UDPListener.h"


namespace NETWORK
{
	//Get IP From Host
	void GetIPAddressOfHost(std::string HostNameStr, SOCKADDR_IN &addressinfo)
	{
		struct addrinfo hints, *res;
		int err;

		memset(&hints, 0, sizeof(hints));
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_family = AF_INET;

		if ((err = getaddrinfo(HostNameStr.c_str(), NULL, &hints, &res)) != 0) {
			printf("error %d\n", err);
			return;
		}

		addressinfo.sin_addr.S_un = ((struct sockaddr_in *)(res->ai_addr))->sin_addr.S_un;
		char str[INET_ADDRSTRLEN];
		inet_ntop(AF_INET, &(addressinfo.sin_addr.S_un.S_addr), str, INET_ADDRSTRLEN);

		printf("[%s] ip address : %s\n", HostNameStr.c_str(), str);

		freeaddrinfo(res);
		return;
	}

	//Initializing to NULL
	UDPListener::UDPListener()
	{
		InitWinsock();
		//DataArrival worker
		WorkerThread = CreateThread(NULL, 0, ListenProcess, (LPVOID)this, CREATE_SUSPENDED, NULL);
	}


	UDPListener::~UDPListener()
	{
	}

	int UDPListener::InitWinsock(void)
	{
		WSAData Data;
		return WSAStartup(0x0202, &Data);
	}

	void UDPListener::StartSocketThread(void)
	{
		this->events[0] = CreateEvent(0, 0, 0, 0);
		WSAResetEvent(this->events[0]);
		WSAEventSelect(this->Sock, this->events[0], 0);
		WSAEventSelect(this->Sock, this->events[0], FD_READ | FD_WRITE);

		//clean the worker
		if (this->WorkerThread != NULL) {
			CloseHandle(this->WorkerThread);
			this->WorkerThread = CreateThread(NULL, 0, ListenProcess, (LPVOID)this, CREATE_SUSPENDED, NULL);
		}

		ResumeThread(this->WorkerThread); //	###TODO### FixMe --^
	}

	void CALLBACK UDPListener::SocketAPCProcess(LPVOID param, const DWORD dwEventID)
	{
		OutputDebugString("EVENTS: INVISABLE\r\n");
		UDPListener *refSocket = reinterpret_cast<UDPListener*>(param);

		//process by events
		if (!IsBadReadPtr((VOID*)refSocket, sizeof(refSocket))) {

			//refSocket->CriticalSection.enter();

			switch (dwEventID)
			{
				case WAIT_OBJECT_0: {
					SOCKADDR_IN Address;
					memset(&Address, 0, sizeof(Address));
					int len = sizeof(Address);
					char *pbIoBuffer;
					//Allocate
					pbIoBuffer = (char *)LocalAlloc(LMEM_FIXED, DATA_SIZE - 1);

					recvfrom(refSocket->Sock, pbIoBuffer, (DATA_SIZE - 1), 0, (SOCKADDR*)&Address, &len);


					//Free
					LocalFree(pbIoBuffer);
					break;
				}
			}
			//process events delete the struct
			//refSocket->CriticalSection.leave();
			return;
		}
	}

	DWORD UDPListener::ListenProcess(LPVOID param) { //(WorkerThread)
		UDPListener *mSocket = reinterpret_cast<UDPListener*>(param);
		DWORD EventID;

		UINT64 LastTick[2] = { GetTickCount64(),0 };

		mSocket->Sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
		
		if (mSocket->BindUDP(mSocket->Sock) == -1)
		{
			printf("Error: unable to bind\n");
			printf("Error code: %d\n", errno);
			return -1;
		}
		//message out
		printf("%s", "UDP Spooled up.\r\n");
		//successful bind call the tracker function.
		mSocket->BindSuccessfull(); //hrmmm

		char data[DATA_SIZE - 1];
		int bytes = 0;
		WSAEVENT hEvent = WSACreateEvent();
		WSANETWORKEVENTS events;
		WSAEventSelect(mSocket->Sock, hEvent, FD_READ | FD_WRITE);

		COMMON::SocketAddrEX Address;
		memset(&Address, 0, sizeof(Address));
		int len = sizeof(Address);

		while (&mSocket->Disconnect != FALSE)
		{
			EventID = WSAWaitForMultipleEvents(2, &hEvent, FALSE, WSA_INFINITE, FALSE);

			if (WSAEnumNetworkEvents(mSocket->Sock, hEvent, &events) == SOCKET_ERROR)
			{
				//cout << "Error";
				OutputDebugString("Error udp thread\r\n");
			}
			else
			{
				if (events.lNetworkEvents & FD_READ)
				{
					bytes = recvfrom(mSocket->Sock, data, (DATA_SIZE - 1), 0, (SOCKADDR*)&Address, &len);
					mSocket->UdpDataArrival(Address, data, bytes);
					OutputDebugString("Data udp thread\r\n");
				}
			}

			//Onboard Tick Timer
			LastTick[1] = GetTickCount64();
			if (((LastTick[1] - LastTick[0]) / 1000) >= 500) //500 seconds so every 5 mins
			{
				mSocket->UDPTick();
				LastTick[0] = LastTick[1];
			}
			//end timer

			Sleep(1);
		}
		return 0;
	}

DWORD UDPListener::ListenProcessx(LPVOID param) { //(WorkerThread)
	UDPListener *mListener = reinterpret_cast<UDPListener*>(param);

#pragma region "The Original Run() section."
	mListener->Sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //UDP packet for DNS queries //AF_INET

	if (mListener->Sock == INVALID_SOCKET)
		return INVALID_SOCKET;


	if (!mListener->BindUDP(mListener->Sock)) { //UDP has no connection
		int x = GetLastError();
		BYTE Data[DATA_SIZE];
		ZeroMemory(Data, DATA_SIZE);
		ReceiveOverlapped Overlapped; // This MUST NOT go out of scope while ReadFileEx is in progress
		memset(&Overlapped, 0, sizeof(ReceiveOverlapped)); //Someone forgot to set the memory
		Overlapped.hEvent = Data;
		Overlapped.Sock = mListener->Sock;
		mListener->Disconnect = false;
		Overlapped.Disconnect = &mListener->Disconnect;
		Overlapped.ThisClsObj = *(UINT_PTR*)&mListener;

		if (ReadFileEx((HANDLE)mListener->Sock, (LPVOID)Data, (DATA_SIZE - 1), &Overlapped, (LPOVERLAPPED_COMPLETION_ROUTINE)ReceiveCompletion) || (GetLastError() == ERROR_IO_PENDING))
		{

			while (!mListener->Disconnect) {
				switch (MsgWaitForMultipleObjectsEx(0, 0, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE)) {

				case WAIT_OBJECT_0:
					MSG msg;

					//

					while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
						UINT m = msg.message;
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					}

					break;

				}
			}
		}
	}
	else {
		int xx = GetLastError();
		closesocket(mListener->Sock);
	}
	closesocket(mListener->Sock);

#pragma endregion


	return 0;
}



	VOID WINAPI UDPListener::SendCompletion(DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred, LPOVERLAPPED lpOverlapped)
	{
		COMMON::MEM::Free(lpOverlapped->hEvent); // Data duplicated
		COMMON::MEM::Free(lpOverlapped);
	}

	void UDPListener::SendData(SOCKET Sock, const char* Data)
	{
		size_t Bytes = strlen(Data);

		void* DuplicateData = COMMON::MEM::Alloc(Bytes);
		LPOVERLAPPED Overlapped = (LPOVERLAPPED)COMMON::MEM::AllocZ(sizeof(OVERLAPPED));

		memcpy(DuplicateData, Data, Bytes);
		Overlapped->hEvent = DuplicateData;

		WriteFileEx((HANDLE)Sock, DuplicateData, Bytes, Overlapped, &SendCompletion);
	}

	//Recieved data
	void WINAPI UDPListener::ReceiveCompletion(DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred,
		ReceiveOverlapped* lpOverlapped)
	{
		if (!dwErrorCode && dwNumberOfBytesTransferred) {
			LPBYTE Data = (LPBYTE)lpOverlapped->hEvent;
			//sockaddr *addr = (sockaddr*)lpOverlapped->hEvent;

			OutputDebugString("From Client: \r\n");
			COMMON::MEM::HexDump(dwNumberOfBytesTransferred, (char *)Data);
			OutputDebugString("\r\n");

			Data[dwNumberOfBytesTransferred] = '\0';
			//(*(UDPListener*)lpOverlapped->ThisClsObj).UdpDataArrival((*(UDPListener*)lpOverlapped->ThisClsObj).Sock, (const char*)Data, dwNumberOfBytesTransferred);

			ReadFileEx((HANDLE)lpOverlapped->Sock, Data, DATA_SIZE - 1, lpOverlapped,
				(LPOVERLAPPED_COMPLETION_ROUTINE)&ReceiveCompletion);
		}
		else {
			closesocket(lpOverlapped->Sock);
			*lpOverlapped->Disconnect = true;
		}
	}

	void UDPListener::DisCon()
	{
		Disconnect = true;
	}

	//Local bind for udp retrieveal
	int UDPListener::BindUDP(SOCKET s)
	{
		SOCKADDR_IN Address;
		memset(&Address, 0, sizeof(Address));
		inet_pton(AF_INET, this->m_IP.c_str(), &(Address.sin_addr.s_addr));

		//Address.sin_addr.s_addr = MAKEIP(0, 0, 0, 0);
		Address.sin_port = RENDIAN_WORD(this->m_port);			//server should not have to be bound to 6112
		Address.sin_family = AF_INET;

		return bind(s, (SOCKADDR*)&Address, sizeof(Address));
	}

	void UDPListener::RunMainLoop()
	{
		Sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //UDP packet for DNS queries //AF_INET

		if (Sock == INVALID_SOCKET)
			return;


		if (!BindUDP(Sock)) { //UDP has no connection
			int x = GetLastError();
			BYTE Data[DATA_SIZE];
			ZeroMemory(Data, DATA_SIZE);
			ReceiveOverlapped Overlapped; // This MUST NOT go out of scope while ReadFileEx is in progress
			memset(&Overlapped, 0, sizeof(ReceiveOverlapped)); //Someone forgot to set the memory
			Overlapped.hEvent = Data;
			Overlapped.Sock = Sock;
			Disconnect = false;
			Overlapped.Disconnect = &Disconnect;
			Overlapped.ThisClsObj = *(UINT_PTR*)this;

			if (ReadFileEx((HANDLE)Sock, (LPVOID)Data, (DATA_SIZE - 1), &Overlapped, (LPOVERLAPPED_COMPLETION_ROUTINE)ReceiveCompletion) || (GetLastError() == ERROR_IO_PENDING))
			{

				while (!Disconnect) {
					switch (MsgWaitForMultipleObjectsEx(0, 0, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE)) {

					case WAIT_OBJECT_0:
						MSG msg;

						//

						while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
							UINT m = msg.message;
							TranslateMessage(&msg);
							DispatchMessage(&msg);
						}

						break;

					}
				}
			}
		}
		else {
			int xx = GetLastError();
			closesocket(Sock);
		}
		closesocket(Sock);
	}

	void UDPListener::StartupRun(const char *ipAddy, unsigned short port)
	{
		this->m_IP = ipAddy;
		this->m_port = port;

		StartSocketThread();
	}

#pragma region "SEND TO CLIENT"
	void UDPListener::SendUdpToClient(unsigned char* message, unsigned int message_length, sockaddr_in ClientAddr)
	{
		int result = sendto(Sock, (const char *)message, message_length, 0, (const sockaddr *)&ClientAddr, sizeof(ClientAddr));
		OutputDebugString(std::to_string(result).c_str());
		OutputDebugString(": Resulted send upd code \r\n");
	}
	void UDPListener::PKT_CONNTEST2(sockaddr_in ClientAddr, unsigned int ServerKey, unsigned int UDPKey, unsigned int Count)
	{
		unsigned char buff[12];
		ZeroMemory(buff, 12);
		for (int i = 0; i < Count; i++)
		{
			*(unsigned short*)(buff + 0) = 0x09;
			*(unsigned int*)(buff + 4) = ServerKey;
			*(unsigned int*)(buff + 8) = UDPKey;
			SendUdpToClient(buff, 12, ClientAddr);
		}
	}
	void UDPListener::PKT_CONNTEST(sockaddr_in ClientAddr, unsigned int UDPKey, unsigned int Count)
	{
		unsigned char buff[8];
		ZeroMemory(buff, 8);
		for (int i = 0; i < Count; i++)
		{
			*(unsigned short*)(buff + 0) = (unsigned short)(0x08);
//			*(unsigned int*)(buff + 4) = ServerKey;
			*(unsigned int*)(buff + 2) = UDPKey;
			SendUdpToClient(buff, 6, ClientAddr);
		}
	}
	void UDPListener::PKT_SERVERPING(sockaddr_in ClientAddr, unsigned int UDPKey, int count)
	{
		unsigned char buff[8];
		ZeroMemory(buff, 8);
		for (int i = 0; i < count; i++)
		{
			*(unsigned int*)(buff + 0) = 0x05;
			*(unsigned int*)(buff + 4) = UDPKey;
			SendUdpToClient(buff, 8, ClientAddr);
		}
	}
	void UDPListener::PKT_20(sockaddr_in ClientAddr, char bytValue)
	{
		unsigned char buff[1];
		ZeroMemory(buff, 1);
		//for (int i = 0; i < 1; i++)
		//{
			*(unsigned char*)(buff + 0) = bytValue;
			SendUdpToClient(buff, 1, ClientAddr);
		//}
	}
#pragma endregion

#pragma region "VIRTUALS"
	void UDPListener::UdpDataArrival(COMMON::SocketAddrEX UdpSock, const char *message, unsigned int message_length) {	}
	void UDPListener::BindSuccessfull(void) { }
	void UDPListener::UDPTick(void) { }
#pragma endregion


}